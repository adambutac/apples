On May 13 of 2008, as written on the official website for the Debian Operating System, “Luciano Bello discovered that the random number generator in Debian’s openssl package is predictable. This is caused by an incorrect Debian-specific change to the openssl package (CVE-2008-0166). As a result, cryptographic key material may be guessable.” (Debian). According to the National Vulnerability Database, “ ‘This flaw was caused by a third-party vendor patch to the OpenSSL library.’ Official Statement from Red Hat (05/13/2008) … which makes it easier for remote attackers to conduct brute force guessing attacks against cryptographic keys.” (NVD). There are many documented events in which similar vulnerabilities were found in Pseudo Random Number Generators (PRNG) because the criteria of secure cryptographic algorithms were left unsatisfied. L’Ecuyer states in his Handbook of Computational Statistics, ”Even some recently proposed or evaluated generators have a very weak theoretical justification” (L’Ecuyer “Efficient and Portable Generators” 742). A strong PRNG is theoretically proven using strong mathematical induction to produce an unpredictable or “fair” output. A strong PRNG must also have a period length large enough to make brute force attacks infeasible with the technology currently available. Even then, a strong PRNG must be subjected to a battery of tests to further improve one’s confidence. When a PRNG fails to satisfy any of the previously stated criteria, it gives vulnerabilities the opportunity to remain unnoticed until it is later discovered by an attacker, in which case it is already too late. Moreover, because the criteria of PRNGs depends on the current state of technology, the criteria must therefore change at a rate equal or greater to the rate of the improvement of technology. To protect the integrity of encrypted data, stronger pseudo random number generators must be implemented, because the security of our data degrades with every passing moment.

A strong PRNG is proven to produce a sequence of numbers, deterministic only to those who know the seed value, by using strong theoretical mathematical justification. As stated by L’Ecuyer, “As of today, the most convenient and most reliable way of generating the random numbers for stochastic simulations appears to be via deterministic algorithms with a solid mathematical basis.” (L’Ecuyer “Random Number Generation” 2). PRNGs used in stochastic simulations have a different criteria from those used in cryptography, however the statement can be applied to all families of random number generators. When considering a PRNG to be used for cryptography, the property of being random, unpredictable, and or having an unbiased aka “fair” output is the most important criterion. As stated by L’Ecuyer in his paper on his statistical testing software package TestU01, “Cryptologists use different quality criteria for RNGs. Their main concern is unpredictability of the forthcoming numbers. Their theoretical analysis of RNGs is usually asymptotic, in the framework of computational complexity theory.” (L’Ecuyer TestU01 2). Using mathematical proof, one abstracts the overall structure of the algorithm in order to remove the unnecessary details of implementation in software and hardware. This process simplifies the PRNG, in order to limit the number of mistakes (hopefully all of them) by theoretically proving using mathematical justification, that the output of the PRNG is unpredictable. This must take place before it is are released in software and or hardware. In the case of Debian’s broken Openssl PRNG, had the engineers used a mathematical proof to analyze their algorithm before it was released, they most likely would have avoided the catastrophe all together. A formal mathematical proof could have revealed that the offending PRNG was in fact deterministic without the seed value after an attacker is given enough of its output. Mathematical proofs also provide additional information as to how strong the PRNG is, and possibly how long it could be considered secure. In the case of Debian’s broken Openssl PRNG, the attacker had to “listen” to the PRNG for a given amount of time to acquire enough data to be able to discover the pattern. Had the engineers used a formal mathematical analysis, they could have found that over time, a pattern is produced in the output of the PRNG, which defeats its property of being unpredictable. In order to ensure that encrypted data remains secure, PRNGs must first be proven mathematically.

Current cryptographic algorithms require strong random number generators because the numbers strength is relative to current technology, and will degenerate over time. A random numbers strength is directly related to its bit length and its period. The bit length and the period of a random number are also directly related, as all numbers represented in binary are restricted above by the curve 2n, where n is its length in bits. A formal definition of the period of a PRNG provided by L’Ecuyer is as follows “The state of the generator is initially s and evolves according to the recurrence sn = T (sn-1), for n = 1 , 2 , 3 , …. The period length is the smallest integer p > 0 such that for some integer t 0 and for all n t, sp+n = sn .” (L’Ecuyer “Random Number Generation” 3). This definition shows that the period is simply the finite amount of numbers that a PRNG can produce before it begins to repeat the sequence. To explain by an example, let’s assume there exists a PRNG with a bit length of 1, therefore having a resulting set of {0,1} and a maximum period of length 2. Assuming that the algorithm is fair, the chance of getting a 0, or a 1 is always exactly 50 percent. Since one already knows all the outcomes of the PRNG, one can see that it is not in any way secure. This type of attack is called a Brute Force attack, and uses an exhaustive search to generate all possible outcomes of the PRNG. It is made clear by this extreme example that having too small of a period removes any confidence of security one may have had previously.
A strong PRNG has a period that is too large to exhaust using technology that is currently available. According to L’Ecuyer in his handbook published in 2012, “Period lengths of 232 or smaller, which are typical for the default generators of many operating systems and software packages, are unacceptably too small. Such period lengths can be exhausted in a matter of minutes on today’s workstations. Even p = 264 is a relatively small period length. Generators with period lengths over 2200 are now available.” (L’Ecuyer “Random Number Generation” 13). With the constantly growing power of the CPU, and the development of large computer clusters or supercomputers, it would be no surprise if a PRNG with a period of 2200 could now be exhausted within a few seconds if not milliseconds. One way way to combat this number degeneration is by designing PRNGs that have a larger period. According to Deng and Lin, “One of the major limitations of the LCG is that its period is limited by the modulus p. Most of the software uses p=231-1. This may have been sufficiently large for most simulations done in the past; however, with better and better computer facilities now available, the scale of simulation study is getting larger and larger.” (145). Also, according to Blum, Blum and Shub, “Cryptographically secure pseudo-random sequence generators (such as the x2 mod N generator) may be viewed as amplifiers of randomness (short random strings are amplified to make long pseudo-random strings).”(Blum, Blum, and Shub 381). Given the way cryptography is currently designed, the best way to combat the chance that an attacker could generate the same random number is to ensure that the period of the PRNG is too large to be exhausted using a brute force attack. It has to be very, very, very large in order to keep the probability that someone generate the same number as low as possible. A Strong PRNG has a period large enough to make brute force attacks infeasible. In 1994, “L’Ecuyer recommended that the period length of a pseudo random number generator should be no less than 260.” (Hill and Wichmann 1614). Whether L’Ecuyer made the statement with cryptography in mind, or as general statement for all PRNGs is unclear. What is clear is that this period length is no longer sufficient in any case. In the context of security, a PRNG with a period of 260may have been considered sufficient in the mid 1990’s, where the average consumer computer system had a CPU with a single 32 bit core, and clock rate of at most a few hundred MHz. Modern computers now have 64 bit processors with clock rates nearing 5GHz and are multi-core. With a modern personal desktop computer a PRNG with a period of 260 would be exhausted too quickly, making it vulnerable to brute force attacks.
As computers become faster, the period of PRNGs becomes relatively smaller. In an attempt to combat this issue, cryptographic and computer engineers work hard to find new ways to generate random numbers with larger periods. The Mersenne Twister, invented by Matsumoto and Nishimura in 1998, “… provides a super astronomical period of 219937-1 and 623-dimensional equidistribution up to 32-bit accuracy, while using a working area of only 624 words.” (3). The invention of the Mersenne Twister was an astonishing movement for the sciences such as physics or biology which use Monte Carlo simulation, but is not suitable for cryptography. The output of the Mersenne Twister is too predictable to be considered secure enough to be utilized in encryption applications. As stated by Matsumoto and Nishimura, “This generator, as it is, does not create cryptographically secure random numbers… output of MT19937 becomes a linear recurring sequence… One can then easily guess the present state from output of a sufficiently large size.” (Matsumoto, Nishimura 7). Although the period was sufficiently large enough to eliminate the threat of a brute force attack, the Mersenne Twister algorithm fails the most valuable criteria of having a unpredictable output. A strong PRNG does not sacrifice its randomness for any other criterion. However, it also cannot have an insufficiently large period.

A strong PRNG is able to pass multiple empirical and statistical evaluations. According to L’Ecuyer, “Once an RNG has been designed and implemented, based on some mathematical analysis of its structure, it is usually submitted to empirical statistical tests that try to detect statistical deficiencies by looking for empirical evidence against [its] hypothesis…” (L’Ecuyer “TestU01” 2). Tools have been developed to help ensure that a PRNG’s output is “random” enough to be used for cryptography. As stated in L’Ecuyer’s paper on TestU01, “Passing many tests improves one’s confidence in the RNG, although it never proves that the RNG is foolproof. In fact, no RNG can pass every conceivable statistical test. One could say that a bad RNG is one that fails simple tests, and a good RNG is one that fails only very complicated tests that are extremely hard to find or impractical to run.” (L’Ecuyer “TestU01” 2). To prove that a PRNG is broken is much easier than proving that it is always going to be correct. This is true for all mathematical proofs. In a mathematical proof of a PRNG, a single counter example can definitively prove that the PRNG is broken, and that it does not satisfy the criteria required for secure cryptographic functions. However, to prove that a system as complex as a PRNG is always correct is not currently possible. The collection of tools used to test PRNGs such as TestU01 are an equivalent to repairing something with duct tape, with the idea that it is “good enough for now” and that “it will hold for a while”. A strong PRNG would be able to be proven to always generate nonlinear and otherwise unpredictable output for all dimensions.

A strong PRNG is efficient enough in its design to be able to run on systems with limited hardware capabilities without sacrifice to its unpredictability. As explained by L’Ecuyer, “Despite the large amount of theoretical research already done on this subject, many of the generators currently in use, especially those on the microcomputers, are seriously flawed … On smaller word size machines, [Multiplicative Linear Congruential Generator]s with large modulus are tricky to implement, while MLCGs with smaller modulus (e.g. m smaller than the largest integer representable on the machine) have periods that are too short to be used safely for serious applications.” (L’Ecuyer “Efficient and Portable Generators” 742-743). Hill and Wichmann published an algorithm designed to work in a 16 bit environment which was common in embedded systems during the time it was conceived. According to McCullough and Wilson, “It has had a ‘good innings’ but its cycle length of about 71012 must now be considered inadequate. It has been reported (McCullough and Wilson, 2005) as having failed some tests at a probability level of less than 10-15, which surely is indicative of a major failing” (Hill and Wichmann 1614). In the context of embedded computers such as wifi access points commonly known as “routers”, and personal computers including mobile devices, it is possible that a strong PRNG was not implemented due to factors such as hardware, time, or budget constraints in the project. Whatever the case may be, it is an extremely irresponsible practice to release a product that advertises as secure but does not do so using a strong PRNG by choice. If a PRNG were designed to be efficient in both its runtime and memory space, there would be no reason to cut corners. It is also possible that the software or hardware was using an older version of a PRNG that was secure at the time. In this case software updates must be mandatory, and hardware must be upgraded or deprecated. Therefore, a strong PRNG is both efficient enough to be portable to multiple architectures, and is easily upgraded or replaced with a stronger version.

In conclusion, a strong pseudo random number generator satisfies all the criteria required by a cryptographic random number generator. In order to justify its correctness, a strong PRNG is proven to produce a sequence of numbers, deterministic only to those who know the seed value, by using strong theoretical mathematical justification. In order to remain secure, a strong PRNG has a period that is too large to perform a brute force attack in a realistic amount of time using state of the art technology. In order to improve one’s confidence that encrypted data will remain secure, a strong PRNG successfully passes multiple empirical and statistical evaluations. Finally, in order to ensure a PRNG is utilized, a strong PRNG is efficient enough in its design to be able to run on systems with limited hardware capabilities without sacrifice to its unpredictability. Current cryptographic technology uses statistical probability to generate a key that is used to encrypt data. By using probability as the function to generate a key, it allows the possibility that someone, perhaps an attacker, to generate the same key. Given enough time, an attacker can generate the same key. Although, with current technology it is not feasible to exhaustively search for the same key, at the rate that technology is improving it is guaranteed to be possible in the future. To improve one’s confidence in the security of encrypted data, stronger PRNGs must be implemented. As it stands now, it is only a matter of time until someone finds your key.